假设存在一个问题：给定一个长度为N的数列A，给出一个值
T，求最长的k，使得总和sum最大

那么假设倍增的算法
p = 1，k = 0， sum = 0
那么p为当前倍增的长度，k为当前枚举到序号，sum为当前的总和
if(sum + s[k + p] - s[k] > T)
	考虑到当前已经越过要合法的点，那么就证明当前倍增的值太大了
	考虑把倍增的值减少，p /= 2
else
	sum = sum + s[k + p] - s[k];
	p = p * 2;
不断重复上述的操作，那么直到p的值为0，就意味当前的sum <= t,即答案为k
